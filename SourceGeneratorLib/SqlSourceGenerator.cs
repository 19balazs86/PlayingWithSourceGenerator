using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGeneratorLib;

[Generator]
public sealed class SqlSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntaxNode, _)       => syntaxNode is ClassDeclarationSyntax,
                transform: static (genSyntaxContext, _) => syntaxProviderTransform(genSyntaxContext))
            .Where(static cds => cds is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation, (spc, source) => outputExecute(spc, source.Left, source.Right));
    }

    // Filter classes annotated with the [Table] attribute
    private static ClassDeclarationSyntax? syntaxProviderTransform(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        return classDeclarationSyntax.HasAttributeWithFullName(context, _tableAttributeFullName)
            ? classDeclarationSyntax
            : null;
    }

    private static void outputExecute(
        SourceProductionContext context,
        Compilation compilation,
        IEnumerable<ClassDeclarationSyntax> classDeclarations)
    {
        foreach (ClassDeclarationSyntax classSyntax in classDeclarations)
        {
            AttributeSyntax? tableAttribute = classSyntax.AttributeLists
                .SelectMany(attributeListSyntax => attributeListSyntax.Attributes)
                .FirstOrDefault(attributeSyntax => _tableAttributeFullName.Equals(attributeSyntax.GetAttributeFullName(compilation)));

            string? tableName = tableAttribute?.ArgumentList?.Arguments.FirstOrDefault()?.ToString().Trim('"');

            if (string.IsNullOrEmpty(tableName))
            {
                continue;
            }

            PropertyDescription[] propertyDescriptions = getPropertyDescriptions(classSyntax).ToArray();

            string className     = $"{classSyntax.Identifier.Text}Sql";
            string namespaceName = classSyntax.GetNamespace();
            int    maxNameLength = propertyDescriptions.Max(pd => pd.ColumnName.Length);

            PropertyDescription primaryKeyPropDesc = propertyDescriptions.First(pd => pd.IsKey);

            string[] selectBodyItems = propertyDescriptions
                .Select(pd => $"{pd.ColumnName.PadRight(maxNameLength)} AS {pd.PropertyName}")
                .Select(x => $"{"",12}{x}") // PadLeft with 12 spaces
                .ToArray();

            string[] updateBodyItems = propertyDescriptions
                .Select(pd => $"{pd.ColumnName.PadRight(maxNameLength)} = @{pd.PropertyName}")
                .Select(x => $"{"",12}{x}")
                .ToArray();

            string code =
                $$""""
                  // <auto-generated/>

                  namespace {{namespaceName}};

                  public static class {{className}}
                  {
                      public const string Select =
                          """
                          SELECT
                  {{string.Join(",\n", selectBodyItems)}}
                          FROM {{tableName}};
                          """;
                  
                       public const string SelectWithPk =
                          """
                          SELECT
                  {{string.Join(",\n", selectBodyItems)}}
                          FROM {{tableName}}
                          WHERE {{primaryKeyPropDesc.ColumnName}} = @{{primaryKeyPropDesc.PropertyName}};
                          """;
                  
                       public const string Insert =
                          """
                          INSERT INTO {{tableName}}
                                     ({{string.Join(", ", propertyDescriptions.Select(pd => pd.ColumnName))}})
                              VALUES ({{string.Join(", ", propertyDescriptions.Select(pd => "@" + pd.PropertyName))}});
                          """;
                  
                       public const string DeleteWithPk = "DELETE FROM {{tableName}} WHERE WHERE {{primaryKeyPropDesc.ColumnName}} = @{{primaryKeyPropDesc.PropertyName}};";
                  
                       public const string UpdateWithPk =
                          """
                          UPDATE {{tableName}}
                          SET
                  {{string.Join(",\n", updateBodyItems)}}
                          WHERE {{primaryKeyPropDesc.ColumnName}} = @{{primaryKeyPropDesc.PropertyName}};
                          """;
                  }
                  """";

            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private static IEnumerable<PropertyDescription> getPropertyDescriptions(ClassDeclarationSyntax classSyntax)
    {
        // For simplicity, working with Syntax instead of Symbol and assume that attributes are used as follows: [Key], [Column("ColumnName")]
        foreach (PropertyDeclarationSyntax propertySyntax in classSyntax.Members.OfType<PropertyDeclarationSyntax>())
        {
            AttributeSyntax[] attributeSyntaxes     = propertySyntax.AttributeLists.SelectMany(al => al.Attributes).ToArray();
            AttributeSyntax?  columnAttributeSyntax = attributeSyntaxes.FirstOrDefault(a => a.Name.ToString() == "Column");

            string  propertyName = propertySyntax.Identifier.ValueText;
            string? columnName   = columnAttributeSyntax?.ArgumentList?.Arguments.FirstOrDefault()?.ToString().Trim('"');
            bool    hasKey       = attributeSyntaxes.FirstOrDefault(a => a.Name.ToString() == "Key") is not null;

            if (!string.IsNullOrEmpty(columnName))
            {
                yield return new PropertyDescription(propertyName, columnName!, hasKey);
            }
        }
    }

    private const string _tableAttributeFullName  = "System.ComponentModel.DataAnnotations.Schema.TableAttribute";
}

internal sealed class PropertyDescription(string _propertyName, string _columnName, bool _isKey = false)
{
    public string PropertyName { get; } = _propertyName;
    public string ColumnName { get; }   = _columnName;
    public bool IsKey { get; }          = _isKey;
}